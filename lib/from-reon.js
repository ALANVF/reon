"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _token3 = _interopRequireWildcard(require("./to-reon/token.js"));

var _env = _interopRequireDefault(require("./to-reon/env.js"));

var _intrinsics = _interopRequireDefault(require("./to-reon/intrinsics.js"));

var Eval = _interopRequireWildcard(require("./to-reon/eval.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// Generated by CoffeeScript 2.5.1
var Reader,
    comment,
    digits,
    fromREON,
    literals,
    makeArray,
    makeBoolean,
    makeFloat,
    makeHexa,
    makeInteger,
    makeObject,
    makeString,
    makeTokenValue,
    makeValue,
    nextKey,
    nextLiteral,
    nextToken,
    _nextValue,
    normalizeStringy,
    _toValueToken,
    _trimSpace,
    wordBase,
    indexOf = [].indexOf;

digits = "(?:\\d+(?:'\\d+)*)";
wordBase = /[^\d\/\\,()[\]{}"'#%$@:;\s][^\/\\,()[\]{}"#%$@:;\s]*/.source;
comment = /^;[^\n]*(?:\n|$)/m;
literals = {
  none: /^none(?=[\s()[\]{}#;"%]|$)/i,
  logic: /^(?:true|false|yes|no|on|off)(?=[\s()[\]{}#;"%]|$)/i,
  word: RegExp("^".concat(wordBase, "(?![:@])")),
  litWord: RegExp("^'(".concat(wordBase, ")")),
  getWord: RegExp("^:(".concat(wordBase, ")")),
  setWord: RegExp("^(".concat(wordBase, "):(?![\\w/])")),
  integer: RegExp("^(?<sign>[+-])?(?<number>".concat(digits, "(?![\\d,.x:/-]))(?<exp>e[+-]?\\d+)?"), "i"),
  hexa: /^([A-F\d]{2,})h(?![\w:@])/,
  "float": RegExp("^(?<sign>[+-])?(?<ipart>".concat(digits, ")[,.](?<fpart>").concat(digits, "(?!\\.))(?<exp>e[+-]?\\d+)?"), "i"),
  money: /^[+-]?[A-Z]{0,3}\$\d+(?:[,.]\d{1,5})?/,
  tuple: /^\d+(?:\.\d+){2,12}/,
  issue: /^#[^\s@#$%^()[\]{},\\;"<>\/]+/,
  ref: /^@[^#$@",;=\\^\/<>()[\]{}]+/,
  email: /^[^\s:\/()[\]{}]+@[^\s:\/()[\]{}]+/,
  url: /^[A-Za-z][\w-]{1,15}:(?:\/{0,3}[^\s[\]()"]+|\/\/)/,
  file: /^%(?![\s%:;()[\]{}])(?:([^\s;"()[\]{}]+)|"((?:\^"|[^"^])*?)")/,
  time: /^[+-]?(?:\d{0,2}:\d\d?(?:\.\d{0,9}|[ap]m)?|\d\d?:\d\d?:\d\d?(?:\.\d{0,9})?(?:[ap]m)?)/i,
  pair: /^[+-]?\d+x[+-]?\d+/i,
  date: /^\d{1,4}-(?:Jan(?:uary)?|Feb(?:uary)?|Mar(?:ch)?|Apr(?:il)?|May|June?|July?|Aug(?:ust)?|Sep(?:tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?|[1-9]|1[012])-\d{1,4}(?:[T\/]\d\d?:\d\d?(?::\d\d?(?:\.\d{1,5})?)?(?:Z|[+-]\d\d?:\d\d?)?)?/,
  "char": /^#"((?:^\(\w+\)|\^.|[^"^]))"/,
  tag: /^<[^=><[\](){}l^"\s](?:"[^"]*"|'[^']*'|[^>"']*)*>/,
  string: /^"((?:\^.|[^"^]+)*)"/
};

Reader = /*#__PURE__*/function () {
  function Reader(input1) {
    _classCallCheck(this, Reader);

    this.input = input1;
    this.pos = 0;
    this.cachedLine = 0;
    this.cachedColumn = 0;
  }

  _createClass(Reader, [{
    key: "match",
    value: function match(rule) {
      var advance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var match, ref;

      if (typeof rule === "string") {
        if (this.input.slice(this.pos).startsWith(rule)) {
          if (advance) {
            this.pos += rule.length;
          }

          return rule;
        } else {
          return null;
        }
      } else {
        if (((ref = match = this.input.slice(this.pos).match(rule)) != null ? ref.index : void 0) === 0) {
          if (advance) {
            this.pos += match[0].length;
          }

          return match;
        } else {
          return null;
        }
      }
    }
  }, {
    key: "next",
    value: function next() {
      var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      return this.input.slice(this.pos, this.pos += length);
    }
  }, {
    key: "peek",
    value: function peek() {
      var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.input.slice(this.pos).slice(offset, length);
    }
  }, {
    key: "eof",
    value: function eof() {
      return this.pos >= this.input.length;
    }
  }, {
    key: "line",
    value: function line() {
      return this.cachedLine = this.input.slice(0, +this.pos + 1 || 9e9).split(/\r\n?|\n/).length;
    }
  }, {
    key: "column",
    value: function column() {
      var _char, column, i, len, pos, ref;

      column = 0;
      ref = this.input;

      for (pos = i = 0, len = ref.length; i < len; pos = ++i) {
        _char = ref[pos];

        switch (false) {
          case !this.eof():
          case pos !== this.pos:
            return this.cachedColumn = column;

          case _char !== "\n":
          case _char !== "\r":
            column = 0;
            break;

          default:
            column++;
        }
      }
    }
  }, {
    key: "error",
    value: function error(message) {
      var line = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var column = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      if (!(line != null && column != null)) {
        line = this.cachedLine;
        column = this.cachedColumn;
      }

      throw new Error("Syntax Error: near ".concat(line, ":").concat(column, ": ").concat(message));
    }
  }]);

  return Reader;
}();

if (Object.fromEntries == null) {
  Object.fromEntries = function (arr) {
    return Object.assign.apply(Object, [{}].concat(_toConsumableArray(Array.from(arr, function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          k = _ref2[0],
          v = _ref2[1];

      return _defineProperty({}, k, v);
    }))));
  };
}

_trimSpace = function trimSpace(reader) {
  if (reader.match(/^\s+/m)) {
    if (reader.match(comment)) {
      return _trimSpace(reader);
    } else {
      return false;
    }
  } else {
    if (reader.match(comment)) {
      return _trimSpace(reader);
    } else {
      return false;
    }
  }
};

nextLiteral = function nextLiteral(reader) {
  var column, i, j, len, len1, len2, level, line, literal, m, match, out, ref, ref1, ref2, values;

  if (reader.match("{")) {
    out = "";
    level = 1;
    line = reader.line();
    column = reader.column();

    while (level > 0 && !reader.eof()) {
      out += function () {
        switch (false) {
          case !reader.match("{"):
            level++;
            return "{";

          case !reader.match("}"):
            level--;
            return "}";

          case !reader.match("^{"):
            return "{";

          case !reader.match("^}"):
            return "}";

          case !reader.match("^^"):
            return "^^";

          default:
            return reader.next();
        }
      }();
    }

    if (level === 0) {
      return _token3.Value.string(out.slice(0, -1));
    } else {
      reader.error("Unexpected EOF, was expecting `}` instead! (starting at ".concat(line, ":").concat(column, ")"));
    }
  }

  if (reader.match("(")) {
    values = [];
    line = reader.line();
    column = reader.column();

    _trimSpace(reader);

    while (!(reader.eof() || reader.peek() === ")")) {
      values.push(nextToken(reader));

      _trimSpace(reader);
    }

    if (reader.eof() || reader.peek() !== ")") {
      reader.error("Unexpected EOF, was expecting `)` instead! (starting at ".concat(line, ":").concat(column, ")"));
    } else {
      reader.next();
      return _token3.Value.paren(values);
    }
  }

  ref = ["string", "hexa", "file", "char"];

  for (i = 0, len = ref.length; i < len; i++) {
    literal = ref[i];

    if (match = reader.match(literals[literal])) {
      return _token3.Value[literal](match[1]);
    }
  }

  ref1 = ["integer", "float"];

  for (j = 0, len1 = ref1.length; j < len1; j++) {
    literal = ref1[j];

    if (match = reader.match(literals[literal])) {
      return _token3.Value[literal](match.groups);
    }
  }

  if (reader.match(literals.none)) {
    return _token3.Value.NONE;
  }

  ref2 = ["logic", "money", "tuple", "issue", "ref", "email", "url", "time", "pair", "date", "tag"];

  for (m = 0, len2 = ref2.length; m < len2; m++) {
    literal = ref2[m];

    if (match = reader.match(literals[literal])) {
      return _token3.Value[literal](match[0]);
    }
  }

  return null;
};

nextKey = function nextKey(reader) {
  var i, len, literal, match, ref;
  ref = ["litWord", "getWord", "setWord"];

  for (i = 0, len = ref.length; i < len; i++) {
    literal = ref[i];

    if (match = reader.match(literals[literal])) {
      return _token3.Value[literal](match[1]);
    }
  }

  if (match = reader.match(literals.word)) {
    return _token3.Value.word(match[0]);
  } else if ((literal = nextLiteral(reader)) != null) {
    return literal;
  } else {
    return reader.error("Invalid key!");
  }
};

_nextValue = function nextValue(reader) {
  var allowWord = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var column, i, key, len, line, literal, match, pairs, ref, value, values;

  switch (false) {
    case !reader.match("["):
      values = [];
      line = reader.line();
      column = reader.column();

      _trimSpace(reader);

      while (!(reader.eof() || reader.peek() === "]")) {
        values.push(_nextValue(reader, allowWord));

        _trimSpace(reader);
      }

      if (reader.eof() || reader.peek() !== "]") {
        return reader.error("Unexpected EOF, was expecting `]` instead! (starting at ".concat(line, ":").concat(column, ")"));
      } else {
        reader.next();
        return _token3.Value.block(values);
      }

      break;

    case !reader.match("#("):
      pairs = [];
      line = reader.line();
      column = reader.column();

      _trimSpace(reader);

      while (!(reader.eof() || reader.peek() === ")")) {
        key = nextKey(reader);

        _trimSpace(reader);

        value = _nextValue(reader, allowWord);

        _trimSpace(reader);

        pairs.push([key, value]);
      }

      if (reader.eof() || reader.peek() !== ")") {
        return reader.error("Unexpected EOF, was expecting `)` instead! (starting at ".concat(line, ":").concat(column, ")"));
      } else {
        reader.next();
        return _token3.Value.map(pairs);
      }

      break;

    case (literal = nextLiteral(reader)) == null:
      return literal;

    default:
      if (allowWord) {
        ref = ["litWord", "getWord", "setWord"];

        for (i = 0, len = ref.length; i < len; i++) {
          literal = ref[i];

          if (match = reader.match(literals[literal])) {
            return _token3.Value[literal](match[1]);
          }
        }

        if (match = reader.match(literals.word)) {
          return _token3.Value.word(match[0]);
        }
      }

      return reader.error("Invalid value near `".concat(reader.peek(), "`!"));
  }
};

nextToken = function nextToken(reader) {
  return _nextValue(reader, true);
};

normalizeStringy = function normalizeStringy(string) {
  var _char2, match, offset, out, str;

  out = "";

  while (string.length > 0) {
    str = string.toLowerCase();

    offset = function () {
      switch (str.slice(0, 2)) {
        case "^^":
          out += "^";
          return 2;

        case '^"':
          out += '\\"';
          return 2;

        case "^-":
          out += "\\t";
          return 2;

        case "^/":
          out += "\\n";
          return 2;

        case "^{":
          out += "{";
          return 2;

        case "^}":
          out += "}";
          return 2;

        case "^@":
          out += "\\0";
          return 2;

        case "^[":
          out += "\\x1B";
          return 2;

        case "^\\":
          out += "\\x1C";
          return 2;

        case "^]":
          out += "\\x1D";
          return 2;

        case "^_":
          out += "\\x1F";
          return 2;

        case "^~":
          out += "\\x7F";
          return 2;

        case "^(":
          switch (false) {
            case !str.startsWith("^(tab)"):
              out += "\\t";
              return 6;

            case !str.startsWith("^(line)"):
              out += "\\n";
              return 7;

            case !str.startsWith("^(null)"):
              out += "\\0";
              return 7;

            case !str.startsWith("^(back)"):
              out += "\\b";
              return 7;

            case !str.startsWith("^(page)"):
              out += "\\x0C";
              return 7;

            case !str.startsWith("^(esc)"):
              out += "\\x1B";
              return 6;

            case !str.startsWith("^(del)"):
              out += "\\x7F";
              return 6;

            default:
              throw new Error("Invalid char!");
          }

          break;

        case "\r\n":
          out += "\\r\\n";
          return 2;

        default:
          switch (false) {
            case string[0] !== "\\":
              out += "\\\\";
              return 1;

            case string[0] !== "\n":
              out += "\\n";
              return 1;

            case string[0] !== "\r":
              out += "\\r";
              return 1;

            case string[0] !== "\t":
              out += "\\t";
              return 1;

            case string[0] !== '"':
              out += '\\"';
              return 1;

            case !(string.length < 2):
              out += string;
              return string.length;

            case !string.match(/^\^[A-Z]/i):
              _char2 = (string[1].toUpperCase().charCodeAt(1) - 64).toString(16);
              out += "\\u00" + "0".repeat(2 - _char2.length) + _char2;
              return 2;

            case !(match = string.match(/^\^\(([\dA-F]{2})\)$/i)):
              out += "\\u" + "0".repeat(4 - match[1].length) + match[1];
              return 4;

            case string[0] !== "^":
              throw new Error("Error in string near `".concat(string.slice(0, 6), "`!"));

            default:
              out += string[0];
              return 1;
          }

      }
    }();

    string = string.slice(offset);
  }

  return out;
};

makeObject = function makeObject(indent, pairs) {
  var _k, _v, k, key, kv, tabs, v;

  if (pairs.length === 0) {
    return "{}";
  }

  tabs = "\t".repeat(indent + 1);

  kv = function () {
    var i, len, results;
    results = [];

    for (i = 0, len = pairs.length; i < len; i++) {
      var _pairs$i = _slicedToArray(pairs[i], 2);

      k = _pairs$i[0];
      v = _pairs$i[1];
      var _k2 = k;

      var _k3 = _slicedToArray(_k2, 2);

      _k = _k3[0];
      _v = _k3[1];

      key = function () {
        switch (_k) {
          case _token3["default"].word:
          case _token3["default"].litWord:
          case _token3["default"].getWord:
          case _token3["default"].setWord:
            return '"' + _v + '"';

          case _token3["default"].integer:
          case _token3["default"]["float"]:
          case _token3["default"].hexa:
            return '"' + makeValue(0, k) + '"';

          default:
            return makeValue(0, k);
        }
      }();

      results.push("\n".concat(tabs).concat(key, ": ").concat(makeValue(indent + 1, v)));
    }

    return results;
  }();

  return "{".concat(kv.join(","), "\n").concat("\t".repeat(indent), "}");
};

makeArray = function makeArray(indent, values) {
  var isMultiLine, tabs, vals, value;

  if (values.length === 0) {
    return "[]";
  }

  vals = function () {
    var i, len, results;
    results = [];

    for (i = 0, len = values.length; i < len; i++) {
      value = values[i];
      results.push(makeValue(indent + 1, value));
    }

    return results;
  }();

  isMultiLine = vals.length > 10 || vals.some(function (str) {
    return indexOf.call(str, "\n") >= 0 || str.length > 80;
  }) || vals.reduce(function (l, s) {
    return l + s.length;
  }, (vals.length - 1) * 2) > 80;

  if (isMultiLine) {
    tabs = "\t".repeat(indent + 1);

    vals = function () {
      var i, len, results;
      results = [];

      for (i = 0, len = vals.length; i < len; i++) {
        value = vals[i];
        results.push("\n" + tabs + value);
      }

      return results;
    }();

    return "[".concat(vals.join(","), "\n").concat("\t".repeat(indent), "]");
  } else {
    return "[".concat(vals.join(", "), "]");
  }
};

makeString = function makeString(_ref4) {
  var _ref5 = _slicedToArray(_ref4, 2),
      kind = _ref5[0],
      value = _ref5[1];

  switch (kind) {
    case _token3["default"].file:
    case _token3["default"]["char"]:
    case _token3["default"].string:
    case _token3["default"].tag:
    case _token3["default"].url:
      return '"' + normalizeStringy(value) + '"';

    case _token3["default"].money:
    case _token3["default"].tuple:
    case _token3["default"].issue:
    case _token3["default"].ref:
    case _token3["default"].email:
    case _token3["default"].time:
    case _token3["default"].pair:
    case _token3["default"].date:
      return '"' + value + '"';
  }
};

makeBoolean = function makeBoolean(logic) {
  var ref;

  if ((ref = logic.toLowerCase()) === "true" || ref === "yes" || ref === "on") {
    return "true";
  } else {
    return "false";
  }
};

makeInteger = function makeInteger(sign, number, exp) {
  if (sign !== "-") {
    sign = "";
  }

  number = number.replace(/'/g, "");
  return "".concat(sign).concat(number).concat(typeof expr !== "undefined" && expr !== null ? expr : "");
};

makeHexa = function makeHexa(hexa) {
  return parseInt(hexa).toString();
};

makeFloat = function makeFloat(sign, ipart, fpart, exp) {
  if (sign !== "-") {
    sign = "";
  }

  ipart = ipart.replace(/'/g, "");
  fpart = fpart.replace(/'/g, "");
  return "".concat(sign).concat(ipart, ".").concat(fpart).concat(exp != null ? exp : "");
};

makeValue = function makeValue(indent, token) {
  var kind, value;

  var _token = _slicedToArray(token, 2);

  kind = _token[0];
  value = _token[1];

  switch (kind) {
    case _token3["default"].map:
      return makeObject(indent, value);

    case _token3["default"].block:
      return makeArray(indent, value);

    case _token3["default"].integer:
      return makeInteger(value.sign, value.number, value.exp);

    case _token3["default"].hexa:
      return makeHexa(value);

    case _token3["default"]["float"]:
      return makeFloat(value.sign, value.ipart, value.fpart, value.exp);

    case _token3["default"].logic:
      return makeBoolean(value);

    case _token3["default"].none:
      return "null";

    case _token3["default"].paren:
      throw new Error("Unexpected paren!");

    default:
      return makeString(token);
  }
};

makeTokenValue = function makeTokenValue(indent, _ref6) {
  var _ref7 = _slicedToArray(_ref6, 2),
      kind = _ref7[0],
      value = _ref7[1];

  switch (kind) {
    case _token3["default"].map:
      return makeObject(indent, value);

    case _token3["default"].block:
      return makeArray(indent, value);

    case _token3["default"].integer:
    case _token3["default"]["float"]:
    case _token3["default"].logic:
      return "".concat(value);

    case _token3["default"].hexa:
      return makeHexa(value);

    case _token3["default"].none:
      return "null";

    case _token3["default"].paren:
      throw new Error("Unexpected paren!");

    case _token3["default"]["char"]:
      return '"' + String.fromCharCode(value) + '"';

    default:
      return '"' + value + '"';
  }
};

_toValueToken = function toValueToken(token) {
  var kind, pair, value;

  var _token2 = _slicedToArray(token, 2);

  kind = _token2[0];
  value = _token2[1];
  return [kind, function () {
    var i, len, ref, results;

    switch (kind) {
      case _token3["default"].block:
      case _token3["default"].paren:
        return value.map(_toValueToken);

      case _token3["default"].map:
        results = [];

        for (i = 0, len = value.length; i < len; i++) {
          pair = value[i];
          results.push(pair.map(_toValueToken));
        }

        return results;
        break;

      case _token3["default"].integer:
        return parseInt(makeInteger(value.sign, value.number, value.exp), 10);

      case _token3["default"].hexa:
        return parseInt(value);

      case _token3["default"]["float"]:
        return parseFloat(makeFloat(value.sign, value.ipart, value.fpart, value.exp));

      case _token3["default"].logic:
        return (ref = value.toLowerCase()) === "true" || ref === "yes" || ref === "on";

      case _token3["default"].none:
        return null;

      case _token3["default"]["char"]:
        return normalizeStringy(value).charCodeAt(0);

      case _token3["default"].file:
      case _token3["default"].string:
      case _token3["default"].tag:
      case _token3["default"].url:
        return normalizeStringy(value);

      default:
        return value;
    }
  }()];
};

var _default = fromREON = function fromREON(input) {
  var _makeValue, env, mainValue, reader, res, tokens;

  reader = new Reader(input);

  _trimSpace(reader);

  if (reader.match(literals.setWord, false)) {
    env = new _env["default"]({
      env: _intrinsics["default"]
    });

    tokens = function () {
      var results;
      results = [];

      while (!(_trimSpace(reader), reader.eof())) {
        results.push(_toValueToken(nextToken(reader)));
      }

      return results;
    }();

    mainValue = tokens.pop();

    if (mainValue[0] !== _token3["default"].map) {
      throw new TypeError("Unexpected ".concat((0, _token3.nameOfToken)(mainValue[0])));
    }

    Eval.evalTokens(env, tokens);
    mainValue = _intrinsics["default"]["compose.deep"].fn(env, [mainValue]);
    _makeValue = makeValue;
    makeValue = makeTokenValue;
    res = makeValue(0, mainValue);
    makeValue = _makeValue;
    return res;
  } else {
    return makeValue(0, _nextValue(reader));
  }
};

exports["default"] = _default;