"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var Util = _interopRequireWildcard(require("../util.js"));

var _token = _interopRequireWildcard(require("./token.js"));

var _eval = require("./eval.js");

var _this = void 0;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

// Generated by CoffeeScript 2.5.1

/* Copying */

/*
$insert_at = (env, [series, [indexK, indexV], value]) =>
	expectValue series, Typesets.series...
	expectToken indexK, Token.integer

	do([seriesK, seriesV] = series, [valueK, valueV] = value) =>
		if seriesK in Typesets.anyString
			str =
				if valueK in Typesets.anyString then valueV
				else $form(env, [value])[1]

			series[1] = seriesV[...indexV] + str + seriesV[indexV..]
		else
			seriesV.splice indexV, 0, value

	series
*/

/* Maps */

/* Control flow */

/* Core */

/* Accessing */

/* Logic */
var $and,
    $append,
    $break,
    $break_return,
    $compose,
    _$compose_deep,
    $continue,
    $copy,
    $copy_deep,
    $do,
    $do_next,
    $either,
    $exit,
    $extend,
    $foreach,
    $form,
    $get,
    $if,
    $length_q,
    $macro,
    $not,
    $or,
    $pick,
    $return,
    $same_q,
    _$set,
    $strict_equal_q,
    $type_q_word,
    $value_q,
    $while,
    $xor,
    Intrinsics,
    PGet,
    PLit,
    PVal,
    TypeMappings,
    expectToken,
    expectValue,
    mapFindPair,
    toLogic,
    unexpectedToken,
    indexOf = [].indexOf;

unexpectedToken = function unexpectedToken(tokenK) {
  throw new TypeError("Unexpected ".concat((0, _token.nameOfToken)(tokenK), "!"));
};

expectToken = function expectToken(valueK) {
  for (var _len = arguments.length, kinds = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    kinds[_key - 1] = arguments[_key];
  }

  if (indexOf.call(kinds, valueK) < 0) {
    return unexpectedToken(valueK);
  }
};

expectValue = function expectValue(_ref) {
  var _ref2 = _slicedToArray(_ref, 2),
      valueK = _ref2[0],
      _ = _ref2[1];

  for (var _len2 = arguments.length, kinds = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    kinds[_key2 - 1] = arguments[_key2];
  }

  return expectToken.apply(void 0, [valueK].concat(kinds));
};

TypeMappings = function () {
  var k, n;

  var TypeMappings = /*#__PURE__*/function () {
    function TypeMappings() {
      _classCallCheck(this, TypeMappings);
    }

    _createClass(TypeMappings, null, [{
      key: "name",
      value: function name(tokenK) {
        return this.tokenToName.get(tokenK);
      }
    }, {
      key: "token",
      value: function token(name) {
        return this.nameToToken.get(name);
      }
    }]);

    return TypeMappings;
  }();

  ;
  TypeMappings.mappings = [[_token["default"].none, "none!"], [_token["default"].logic, "logic!"], [_token["default"].word, "word!"], [_token["default"].litWord, "lit-word!"], [_token["default"].getWord, "get-word!"], [_token["default"].setWord, "set-word!"], [_token["default"].integer, "integer!"], [_token["default"].hexa, "hexa!"], [_token["default"]["float"], "float!"], [_token["default"].money, "money!"], [_token["default"].tuple, "tuple!"], [_token["default"].issue, "issue!"], [_token["default"].ref, "ref!"], [_token["default"].email, "email!"], [_token["default"].url, "url!"], [_token["default"].file, "file!"], [_token["default"].time, "time!"], [_token["default"].pair, "pair!"], [_token["default"].date, "date!"], [_token["default"]["char"], "char!"], [_token["default"].tag, "tag!"], [_token["default"].string, "string!"], [_token["default"].block, "block!"], [_token["default"].map, "map!"], [_token["default"].paren, "paren!"]];
  TypeMappings.tokenToName = new Map(TypeMappings.mappings);
  TypeMappings.nameToToken = new Map(function () {
    var j, len, ref, results;
    ref = TypeMappings.mappings;
    results = [];

    for (j = 0, len = ref.length; j < len; j++) {
      var _ref$j = _slicedToArray(ref[j], 2);

      k = _ref$j[0];
      n = _ref$j[1];
      results.push([n, k]);
    }

    return results;
  }.call(this));
  return TypeMappings;
}.call(void 0);

$macro = function $macro(_, _ref3) {
  var _ref4 = _slicedToArray(_ref3, 2),
      _ref4$ = _slicedToArray(_ref4[0], 2),
      paramsK = _ref4$[0],
      params = _ref4$[1],
      _ref4$2 = _slicedToArray(_ref4[1], 2),
      bodyK = _ref4$2[0],
      body = _ref4$2[1];

  var param, paramK;
  expectToken(paramsK, _token["default"].block);
  expectToken(bodyK, _token["default"].block);

  params = function () {
    var j, len, results;
    results = [];

    for (j = 0, len = params.length; j < len; j++) {
      var _params$j = _slicedToArray(params[j], 2);

      paramK = _params$j[0];
      param = _params$j[1];

      switch (paramK) {
        case _token["default"].word:
          results.push([_eval.Param.val, param]);
          break;

        case _token["default"].getWord:
          results.push([_eval.Param.get, param]);
          break;

        case _token["default"].litWord:
          results.push([_eval.Param.lit, param]);
          break;

        default:
          results.push(unexpectedToken(paramK));
      }
    }

    return results;
  }();

  return new _eval.Macro(params, _toConsumableArray(body));
};

$type_q_word = function $type_q_word(_, _ref5) {
  var _ref6 = _slicedToArray(_ref5, 1),
      _ref6$ = _slicedToArray(_ref6[0], 2),
      valueK = _ref6$[0],
      __ = _ref6$[1];

  return _token.Value.litWord(TypeMappings.name(valueK));
};

$value_q = function $value_q(env, _ref7) {
  var _ref8 = _slicedToArray(_ref7, 1),
      _ref8$ = _slicedToArray(_ref8[0], 2),
      wordK = _ref8$[0],
      word = _ref8$[1];

  expectToken(wordK, _token["default"].word, _token["default"].litWord);
  return _token.Value.logic(env.has(word));
};

$get = function $get(env, _ref9) {
  var _ref10 = _slicedToArray(_ref9, 1),
      _ref10$ = _slicedToArray(_ref10[0], 2),
      wordK = _ref10$[0],
      word = _ref10$[1];

  var value;
  expectToken(wordK, _token["default"].word, _token["default"].litWord);

  if (env.has(word)) {
    value = env.get(word);

    if ((0, _eval.isAnyMacro)(value)) {
      throw new Error("Cannot get macro! values");
    } else {
      return value;
    }
  } else {
    throw new Error("Word `".concat(word, "` doesn't exist!"));
  }
};

_$set = function $set(env, _ref11) {
  var _ref12 = _slicedToArray(_ref11, 2),
      _ref12$ = _slicedToArray(_ref12[0], 2),
      wordK = _ref12$[0],
      word = _ref12$[1],
      value = _ref12[1];

  var i, words;
  expectToken(wordK, _token["default"].word, _token["default"].litWord, _token["default"].block);

  if (wordK === _token["default"].block) {
    words = word;
    return _token.Value.block(function () {
      var j, l, len, len1, results, results1;

      if ((0, _eval.isAnyMacro)(value) || value[0] !== _token["default"].block) {
        results = [];

        for (j = 0, len = words.length; j < len; j++) {
          var _words$j = _slicedToArray(words[j], 2);

          wordK = _words$j[0];
          word = _words$j[1];
          expectToken(wordK, _token["default"].word, _token["default"].litWord);
          results.push(env.set(word, value));
        }

        return results;
      } else {
        results1 = [];

        for (i = l = 0, len1 = words.length; l < len1; i = ++l) {
          word = words[i];
          results1.push(_$set(env, word, value[1][i]));
        }

        return results1;
      }
    }());
  }
};
/* Evaluation */
//$reduce = (env, [value])
// acts like compose/only


$compose = function $compose(env, _ref13) {
  var _ref14 = _slicedToArray(_ref13, 1),
      value = _ref14[0];

  var expand;

  expand = function expand(val) {
    if (val[0] === _token["default"].paren) {
      return (0, _eval.evalTokens)(env, val[1]);
    } else {
      return val;
    }
  };

  return function (_ref15) {
    var _ref16 = _slicedToArray(_ref15, 2),
        valueK = _ref16[0],
        valueV = _ref16[1];

    var elem, pair;

    switch (valueK) {
      case _token["default"].block:
        return [valueK, function () {
          var j, len, results;
          results = [];

          for (j = 0, len = valueV.length; j < len; j++) {
            elem = valueV[j];
            results.push(expand(elem));
          }

          return results;
        }()];

      case _token["default"].map:
        return [valueK, function () {
          var j, len, results;
          results = [];

          for (j = 0, len = valueV.length; j < len; j++) {
            pair = valueV[j];
            results.push(pair.map(expand));
          }

          return results;
        }()];

      default:
        return value;
    }
  }(value);
}; // acts like compose/only/deep


_$compose_deep = function $compose_deep(env, _ref17) {
  var _ref18 = _slicedToArray(_ref17, 1),
      value = _ref18[0];

  var expand;

  expand = function expand(val) {
    return _$compose_deep(env, [val]);
  };

  return function (_ref19) {
    var _ref20 = _slicedToArray(_ref19, 2),
        valueK = _ref20[0],
        valueV = _ref20[1];

    var elem, pair;

    switch (valueK) {
      case _token["default"].block:
        return [valueK, function () {
          var j, len, results;
          results = [];

          for (j = 0, len = valueV.length; j < len; j++) {
            elem = valueV[j];
            results.push(expand(elem));
          }

          return results;
        }()];

      case _token["default"].map:
        return [valueK, function () {
          var j, len, results;
          results = [];

          for (j = 0, len = valueV.length; j < len; j++) {
            pair = valueV[j];
            results.push(pair.map(expand));
          }

          return results;
        }()];

      case _token["default"].paren:
        return (0, _eval.evalTokens)(env, valueV);

      default:
        return value;
    }
  }(value);
}; //$load = (env, [value])


$do = function $do(env, _ref21) {
  var _ref22 = _slicedToArray(_ref21, 1),
      value = _ref22[0];

  switch (value[0]) {
    case _token["default"].block:
    case _token["default"].paren:
      return (0, _eval.evalTokens)(env, value[1]);

    case _token["default"].string:
      throw "todo!";

    default:
      return value;
  }
};

$do_next = function $do_next(env, _ref23) {
  var _ref24 = _slicedToArray(_ref23, 2),
      value = _ref24[0],
      _ref24$ = _slicedToArray(_ref24[1], 2),
      wordK = _ref24$[0],
      wordV = _ref24$[1];

  expectToken(wordK, _token["default"].word, _token["default"].litWord);
  return function (_ref25) {
    var _ref26 = _slicedToArray(_ref25, 2),
        valueK = _ref26[0],
        valueV = _ref26[1];

    var res, tokens;

    switch (valueK) {
      case _token["default"].block:
      case _token["default"].paren:
        tokens = _toConsumableArray(valueV);
        res = (0, _eval.evalNextExpr)(env, tokens);
        env.set(wordV, [valueK, tokens]);
        return res;

      case _token["default"].string:
        throw "todo!";

      default:
        return value;
    }
  }(value);
};

mapFindPair = function mapFindPair(map, key) {
  var j, k, kK, kV, len, pair, ref;

  if (ref = key[0], indexOf.call(_token.Typesets.anyWord, ref) >= 0) {
    key = [_token["default"].word, key[1]];
  }

  for (j = 0, len = map.length; j < len; j++) {
    pair = map[j];

    var _k = k = pair[0];

    var _k2 = _slicedToArray(_k, 2);

    kK = _k2[0];
    kV = _k2[1];

    if (indexOf.call(_token.Typesets.anyWord, kK) >= 0) {
      k = [_token["default"].word, kV];
    }

    if ($strict_equal_q(null, [k, key])[1]) {
      return pair;
    }
  }

  return null;
};

$pick = function $pick(env, _ref27) {
  var _ref28 = _slicedToArray(_ref27, 2),
      _ref28$ = _slicedToArray(_ref28[0], 2),
      valueK = _ref28$[0],
      valueV = _ref28$[1],
      index = _ref28[1];

  return function (_ref29) {
    var _ref30 = _slicedToArray(_ref29, 2),
        indexK = _ref30[0],
        indexV = _ref30[1];

    var _char, pair, ref;

    if (indexOf.call(_token.Typesets.anyString, valueK) >= 0) {
      expectToken(indexK, _token["default"].integer);

      if ((_char = valueV.charCodeAt(indexV)) != null) {
        return _token.Value["char"](_char);
      } else {
        return _token.Value.NONE;
      }
    } else {
      switch (valueK) {
        case _token["default"].block:
        case _token["default"].paren:
          expectToken(indexK, _token["default"].integer);
          return (ref = valueV[indexV]) != null ? ref : _token.Value.NONE;

        case _token["default"].map:
          // todo: validate key
          if ((pair = mapFindPair(valueV, index)) != null) {
            return pair[1];
          } else {
            return _token.Value.NONE;
          }

          break;

        case _token["default"].pair:
        case _token["default"].time:
        case _token["default"].date:
        case _token["default"].tuple:
          throw "todo!";

        default:
          return unexpectedToken(tokenK);
      }
    }
  }(index);
};

$copy = function $copy(_, _ref31) {
  var _ref32 = _slicedToArray(_ref31, 1),
      _ref32$ = _slicedToArray(_ref32[0], 2),
      valueK = _ref32$[0],
      valueV = _ref32$[1];

  var pair;
  return [valueK, function () {
    var j, len, results;

    switch (valueK) {
      case _token["default"].paren:
      case _token["default"].block:
        return _toConsumableArray(valueV);

      case _token["default"].map:
        results = [];

        for (j = 0, len = valueV.length; j < len; j++) {
          var _valueV$j = _toArray(valueV[j]);

          pair = _valueV$j.slice(0);
          results.push(pair);
        }

        return results;
        break;

      default:
        return valueV;
    }
  }()];
};

$copy_deep = function $copy_deep(_, _ref33) {
  var _ref34 = _slicedToArray(_ref33, 1),
      value = _ref34[0];

  var _copy_deep;

  _copy_deep = function copy_deep(_ref35) {
    var _ref36 = _slicedToArray(_ref35, 2),
        valueK = _ref36[0],
        valueV = _ref36[1];

    var pair;
    return [valueK, function () {
      var j, len, results;

      switch (valueK) {
        case _token["default"].paren:
        case _token["default"].block:
          return valueV.map(_copy_deep);

        case _token["default"].map:
          results = [];

          for (j = 0, len = valueV.length; j < len; j++) {
            pair = valueV[j];
            results.push(pair.map(_copy_deep));
          }

          return results;
          break;

        default:
          return valueV;
      }
    }()];
  };

  return _copy_deep(value);
};

toLogic = function toLogic(_ref37) {
  var _ref38 = _slicedToArray(_ref37, 2),
      valueK = _ref38[0],
      valueV = _ref38[1];

  switch (valueK) {
    case _token["default"].none:
      return false;

    case _token["default"].logic:
      return valueV;

    default:
      return true;
  }
};

$not = function $not(_, _ref39) {
  var _ref40 = _slicedToArray(_ref39, 1),
      value = _ref40[0];

  return _token.Value.logic(!toLogic(value));
};

$and = function $and(_, _ref41) {
  var _ref42 = _slicedToArray(_ref41, 2),
      left = _ref42[0],
      right = _ref42[1];

  expectValue(right, left[0]);

  switch (left[0]) {
    case _token["default"].logic:
      return _token.Value.logic(toLogic(left) && toLogic(right));

    default:
      throw "todo!";
  }
};

$or = function $or(_, _ref43) {
  var _ref44 = _slicedToArray(_ref43, 2),
      left = _ref44[0],
      right = _ref44[1];

  expectValue(right, left[0]);

  switch (left[0]) {
    case _token["default"].logic:
      return _token.Value.logic(toLogic(left) || toLogic(right));

    default:
      throw "todo!";
  }
};

$xor = function $xor(_, _ref45) {
  var _ref46 = _slicedToArray(_ref45, 2),
      left = _ref46[0],
      right = _ref46[1];

  expectValue(right, left[0]);

  switch (left[0]) {
    case _token["default"].logic:
      return _token.Value.logic(toLogic(left) !== toLogic(right));

    default:
      throw "todo!";
  }
};
/* Relational */
//$equal
//$lesser
// basic for now


$strict_equal_q = function $strict_equal_q(_, _ref47) {
  var _ref48 = _slicedToArray(_ref47, 2),
      left = _ref48[0],
      right = _ref48[1];

  var _strict_equal_q;

  _strict_equal_q = function strict_equal_q(_ref49, _ref50) {
    var _ref51 = _slicedToArray(_ref49, 2),
        leftK = _ref51[0],
        leftV = _ref51[1];

    var _ref52 = _slicedToArray(_ref50, 2),
        rightK = _ref52[0],
        rightV = _ref52[1];

    return leftK === rightK && function () {
      switch (leftK) {
        case _token["default"].none:
          return true;

        case _token["default"].block:
        case _token["default"].paren:
          return leftV.length === rightV.length && Util.all(Util.zip(leftV, rightV, _strict_equal_q));

        case _token["default"].map:
          return leftV.length === rightV.length && Util.all(Util.zip(leftV, rightV, function (_ref53, _ref54) {
            var _ref55 = _slicedToArray(_ref53, 2),
                k1 = _ref55[0],
                v1 = _ref55[1];

            var _ref56 = _slicedToArray(_ref54, 2),
                k2 = _ref56[0],
                v2 = _ref56[1];

            return _strict_equal_q(k1, k2) && _strict_equal_q(v1, v2); // todo: make this better
          }));

        default:
          return leftV === rightV;
      }
    }.call(_this);
  };

  return _token.Value.logic(_strict_equal_q(left, right));
};

$same_q = function $same_q(_, _ref57) {
  var _ref58 = _slicedToArray(_ref57, 2),
      left = _ref58[0],
      right = _ref58[1];

  return _token.Value.logic(function (_ref59, _ref60) {
    var _ref61 = _slicedToArray(_ref59, 2),
        leftK = _ref61[0],
        leftV = _ref61[1];

    var _ref62 = _slicedToArray(_ref60, 2),
        rightK = _ref62[0],
        rightV = _ref62[1];

    if (leftK === rightK) {
      if (indexOf.call(_token.Typesets.seriesLike, leftK) >= 0) {
        return left === right;
      } else {
        return leftV === rightV;
      }
    }
  }(left, right));
};

$if = function $if(env, _ref63) {
  var _ref64 = _slicedToArray(_ref63, 2),
      value = _ref64[0],
      _ref64$ = _slicedToArray(_ref64[1], 2),
      bodyK = _ref64$[0],
      bodyV = _ref64$[1];

  expectToken(bodyK, _token["default"].block);

  if (toLogic(value)) {
    return (0, _eval.evalTokens)(env, bodyV);
  } else {
    return _token.Value.NONE;
  }
};

$either = function $either(env, _ref65) {
  var _ref66 = _slicedToArray(_ref65, 3),
      value = _ref66[0],
      _ref66$ = _slicedToArray(_ref66[1], 2),
      thenK = _ref66$[0],
      thenV = _ref66$[1],
      _ref66$2 = _slicedToArray(_ref66[2], 2),
      elseK = _ref66$2[0],
      elseV = _ref66$2[1];

  expectToken(thenK, _token["default"].block);
  expectToken(elseK, _token["default"].block);
  return (0, _eval.evalTokens)(env, toLogic(value) ? thenV : elseV);
};

$while = function $while(env, _ref67) {
  var _ref68 = _slicedToArray(_ref67, 2),
      _ref68$ = _slicedToArray(_ref68[0], 2),
      valueK = _ref68$[0],
      valueV = _ref68$[1],
      _ref68$2 = _slicedToArray(_ref68[1], 2),
      bodyK = _ref68$2[0],
      bodyV = _ref68$2[1];

  var e, res;
  expectToken(valueK, _token["default"].block);
  expectToken(bodyK, _token["default"].block);
  res = _token.Value.NONE;

  while (toLogic((0, _eval.evalTokens)(env, valueV))) {
    try {
      res = (0, _eval.evalTokens)(env, bodyV);
    } catch (error) {
      e = error;

      switch (false) {
        case !(e instanceof _eval.ControlFlow.Continue):
          continue;

        case !(e instanceof _eval.ControlFlow.Break):
          return e.value;

        default:
          throw e;
      }
    }
  }

  return res;
};

$foreach = function $foreach(env, _ref69) {
  var _ref70 = _slicedToArray(_ref69, 3),
      _ref70$ = _slicedToArray(_ref70[0], 2),
      wordK = _ref70$[0],
      wordV = _ref70$[1],
      _ref70$2 = _slicedToArray(_ref70[1], 2),
      seriesK = _ref70$2[0],
      seriesV = _ref70$2[1],
      _ref70$3 = _slicedToArray(_ref70[2], 2),
      bodyK = _ref70$3[0],
      bodyV = _ref70$3[1];

  var _, c, e, elem, elements, elems, j, k, l, len, len1, pair, ref, res, tmpEnv, v, word, words;

  expectToken(wordK, _token["default"].word, _token["default"].litWord, _token["default"].block);
  expectToken.apply(void 0, [seriesK].concat(_toConsumableArray(_token.Typesets.seriesLike)));
  expectToken(bodyK, _token["default"].block);
  word = wordK !== _token["default"].block ? wordV : (words = function () {
    var j, len, results;
    results = [];

    for (j = 0, len = wordV.length; j < len; j++) {
      var _wordV$j = _slicedToArray(wordV[j], 2);

      k = _wordV$j[0];
      v = _wordV$j[1];
      expectToken(k, _token["default"].word, _token["default"].litWord);
      results.push(v);
    }

    return results;
  }(), words.length === 1 ? words[0] : words);

  elements = function () {
    var j, l, len, len1, results, results1;

    switch (seriesK) {
      case _token["default"].block:
      case _token["default"].paren:
        return seriesV;

      case _token["default"].map:
        if (typeof word === "string") {
          results = [];

          for (j = 0, len = seriesV.length; j < len; j++) {
            var _seriesV$j = _slicedToArray(seriesV[j], 2);

            k = _seriesV$j[0];
            _ = _seriesV$j[1];
            results.push(k);
          }

          return results;
        } else {
          var _ref71;

          return (_ref71 = []).concat.apply(_ref71, _toConsumableArray(seriesV));
        }

        break;

      default:
        results1 = [];

        for (l = 0, len1 = seriesV.length; l < len1; l++) {
          c = seriesV[l];
          results1.push(_token.Value["char"](c.charCodeAt(0)));
        }

        return results1;
    }
  }();

  res = _token.Value.NONE;

  if (typeof word === "string") {
    for (j = 0, len = elements.length; j < len; j++) {
      elem = elements[j];

      try {
        res = (0, _eval.evalTokens)(env.newInner(_defineProperty({}, word, elem)), bodyV);
      } catch (error) {
        e = error;

        switch (false) {
          case !(e instanceof _eval.ControlFlow.Continue):
            continue;

          case !(e instanceof _eval.ControlFlow.Break):
            return e.value;

          default:
            throw e;
        }
      }
    }
  } else {
    words = word;
    ref = Util.chunk(elements, words.length, _token.Value.NONE);

    for (l = 0, len1 = ref.length; l < len1; l++) {
      elems = ref[l];

      try {
        tmpEnv = env.newInner(function () {
          var len2, m, ref1, results;
          ref1 = Util.zip(words, elems);
          results = [];

          for (m = 0, len2 = ref1.length; m < len2; m++) {
            pair = ref1[m];
            results.push(pair);
          }

          return results;
        }());
        res = (0, _eval.evalTokens)(tmpEnv, bodyV);
      } catch (error) {
        e = error;

        switch (false) {
          case !(e instanceof _eval.ControlFlow.Continue):
            continue;

          case !(e instanceof _eval.ControlFlow.Break):
            return e.value;

          default:
            throw e;
        }
      }
    }
  }
};

$return = function $return(_, _ref72) {
  var _ref73 = _slicedToArray(_ref72, 1),
      value = _ref73[0];

  throw new _eval.ControlFlow.Return(value);
};

$exit = function $exit(_, arg) {
  var arg;
  arg;
  throw new _eval.ControlFlow.Return();
};

$break = function $break(_, arg) {
  var arg;
  arg;
  throw new _eval.ControlFlow.Break();
};

$break_return = function $break_return(_, _ref74) {
  var _ref75 = _slicedToArray(_ref74, 1),
      value = _ref75[0];

  throw new _eval.ControlFlow.Break(value);
};

$continue = function $continue(_, arg) {
  var arg;
  arg;
  throw new _eval.ControlFlow.Continue(value);
};
/* Conversion */

/* Math (maybe) */

/* Strings */
// basic for now


$form = function $form(_, _ref76) {
  var _ref77 = _slicedToArray(_ref76, 1),
      value = _ref77[0];

  var _form;

  _form = function form(_ref78) {
    var _ref79 = _slicedToArray(_ref78, 2),
        valueK = _ref79[0],
        valueV = _ref79[1];

    if (indexOf.call([].concat(_toConsumableArray(_token.Typesets.anyString), _toConsumableArray(_token.Typesets.anyWord), _toConsumableArray(_token.Typesets.otherStringy)), valueK) >= 0) {
      return valueV;
    } else {
      switch (valueK) {
        case _token["default"].none:
          return "none";

        case _token["default"].logic:
        case _token["default"].integer:
        case _token["default"]["float"]:
          return "".concat(valueV);

        case _token["default"].block:
        case _token["default"].paren:
          return valueV.map(_form).join(" ");

        case _token["default"]["char"]:
          return String.fromCharCode(valueV);

        default:
          throw "todo!";
      }
    }
  };

  return _token.Value.string(_form(value));
}; //$mold

/* Series */


$length_q = function $length_q(_, _ref80) {
  var _ref81 = _slicedToArray(_ref80, 1),
      _ref81$ = _slicedToArray(_ref81[0], 2),
      seriesK = _ref81$[0],
      seriesV = _ref81$[1];

  expectToken.apply(void 0, [seriesK].concat(_toConsumableArray(_token.Typesets.seriesLike), [_token["default"].tuple, _token["default"].none]));

  if (seriesK === _token["default"].none) {
    return _token.Value.NONE;
  } else {
    return _token.Value.integer(function () {
      if (seriesK !== _token["default"].tuple) {
        return seriesV.length;
      } else {
        throw "todo!";
      }
    }());
  }
};

$append = function $append(env, _ref82) {
  var _ref83 = _slicedToArray(_ref82, 2),
      series = _ref83[0],
      value = _ref83[1];

  expectValue.apply(void 0, [series].concat(_toConsumableArray(_token.Typesets.series)));

  (function (_ref84, _ref85) {
    var _ref86 = _slicedToArray(_ref84, 2),
        seriesK = _ref86[0],
        seriesV = _ref86[1];

    var _ref87 = _slicedToArray(_ref85, 2),
        valueK = _ref87[0],
        valueV = _ref87[1];

    if (indexOf.call(_token.Typesets.anyString, seriesK) >= 0) {
      return series[1] += indexOf.call(_token.Typesets.anyString, valueK) >= 0 ? valueV : $form(env, [value])[1];
    } else {
      return seriesV.push(value);
    }
  })(series, value);

  return series;
};

$extend = function $extend(_, _ref88) {
  var _ref89 = _slicedToArray(_ref88, 3),
      _ref89$ = _slicedToArray(_ref89[0], 2),
      mapK = _ref89$[0],
      mapV = _ref89$[1],
      key = _ref89[1],
      value = _ref89[2];

  var pair;
  expectToken(mapK, _token["default"].map);

  if ((pair = mapFindPair(mapV, key)) != null) {
    pair[1] = value;
  } else {
    mapV.push([key, value]);
  }

  return value;
};

PVal = _eval.Param.val;
PGet = _eval.Param.get;
PLit = _eval.Param.lit;

var _default = Intrinsics = {
  macro: new _eval.Intrinsic([PVal, PVal], $macro),
  "type?.word": new _eval.Intrinsic([PVal], $type_q_word),
  "value?": new _eval.Intrinsic([PVal], $value_q),
  get: new _eval.Intrinsic([PVal], $get),
  set: new _eval.Intrinsic([PVal, PVal], _$set),
  compose: new _eval.Intrinsic([PVal], $compose),
  "compose.deep": new _eval.Intrinsic([PVal], _$compose_deep),
  "do": new _eval.Intrinsic([PVal], $do),
  "do.next": new _eval.Intrinsic([PVal, PVal], $do_next),
  pick: new _eval.Intrinsic([PVal, PVal], $pick),
  copy: new _eval.Intrinsic([PVal], $copy),
  "copy.deep": new _eval.Intrinsic([PVal], $copy_deep),
  not: new _eval.Intrinsic([PVal], $not),
  and: new _eval.Intrinsic([PVal, PVal], $and),
  or: new _eval.Intrinsic([PVal, PVal], $or),
  xor: new _eval.Intrinsic([PVal, PVal], $xor),
  "strict-equal?": new _eval.Intrinsic([PVal, PVal], $strict_equal_q),
  "same?": new _eval.Intrinsic([PVal, PVal], $same_q),
  "if": new _eval.Intrinsic([PVal, PVal], $if),
  either: new _eval.Intrinsic([PVal, PVal, PVal], $either),
  "while": new _eval.Intrinsic([PVal, PVal], $while),
  foreach: new _eval.Intrinsic([PLit, PVal, PVal], $foreach),
  "return": new _eval.Intrinsic([PVal], $return),
  exit: new _eval.Intrinsic([], $exit),
  "break": new _eval.Intrinsic([], $break),
  "break.return": new _eval.Intrinsic([PVal], $break_return),
  "continue": new _eval.Intrinsic([], $continue),
  form: new _eval.Intrinsic([PVal], $form),
  "length?": new _eval.Intrinsic([PVal], $length_q),
  append: new _eval.Intrinsic([PVal, PVal], $append),
  //"insert-at": new Intrinsic [PVal, PVal, PVal], $insert_at
  extend: new _eval.Intrinsic([PVal, PVal, PVal], $extend)
};

exports["default"] = _default;